[[toc]]

## 从输入URL到整个页面显示在用户面前发生了什么 {#page-load-since-enter-url}

::: tip 大体流程
1. 浏览器从url中解析出服务器的主机名
2. 浏览器将服务器的主机名转换成服务器的IP地址（DNS）
3. 浏览器将端口号从url中解析出来
4. 浏览器建立一条与web服务器的TCP连接
5. 浏览器向服务器发送一条HTTP的请求报文
6. 服务器向浏览器回送一条HTTP的响应报文
7. 关闭连接，浏览器渲染
:::

### 1. 浏览器查找域名对应的IP地址 {#dns}

**IP地址**：IP协议为互联网上的每一个网络和每一台主机都分配的一个逻辑地址。通过IP地址才能确定一台主机（服务器）的位置。

**域名（DN，Domain Name）**：IP地址不便于用户记忆和使用，故用域名来代替纯数字的IP地址。

**DNS（Domain Name System）**：每个域名都对应**一个或多个**提供相同服务的服务器的IP地址，只有知道服务器IP地址才能建立连接，所以需要通过DNS把域名解析成一个IP地址。

::: tip 域名和IP的关系
域名和IP不是一一对应的关系，可以把多个提供相同服务的服务器IP设置为同一个域名，
但在同一时刻一个域名只能解析出一个IP地址；
同时，一个IP地址可以绑定多个域名，数量不限；
:::

**DNS重定向**

这里的知识点，对前端而言只要知道使用CDN存放静态资源这种优化策略的原理是DNS负载均衡：
如果一个大型网站的所有请求都由同一个服务器进行处理，是不现实的；
并且对用户而言，用户并不关注具体是哪台机器处理了他的请求。
因此，DNS可以根据多个服务器中每个服务器的负载量、该机器离用户的地理位置的距离等信息
返回其中某个适合的主机的IP地址，这个过程就是**DNS负载均衡，又叫做DNS重定向**。
**CDN（Content Delivery Network）就是利用DNS的重定向技术**，DNS服务器会返回一个跟用户最接近的点的IP地址。

### 2. 浏览器根据IP地址与服务器建立socket连接 {#three-way-handshake}

**建立连接——三次握手**

知道了服务器的IP地址，便可开始与服务器建立连接了，通信连接的建立需要经历以下三个过程：

1. 客户端首先发送一个带有SYN标志的数据包给服务端（您好，我想认识你）；
2. 服务端接受SYN数据包之后，回传一个SYN/ACK标志的数据包以示传达确认连接信息（好的，很高兴认识你）；
3. 客户端收到SYN/ACK的确认数据包之后，再回传一个ACK标志的数据包给服务端，表示‘握手’结束（我也很高兴认识你），至此，客户端便与服务器建立了连接。

说明：

- TCP协议：三次握手的过程采用TCP协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信息，协议会要求重新发送信号。

::: tip TCP的作用是啥？
- 提供无差错的数据传输
- 按序传输（数据总是会按照发送顺序到达）
- 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）
:::

### 3. 浏览器与服务器通信：浏览器发出请求、服务器处理请求、渲染 {#communicate-render}

当服务器与客户端建立了连接之后，客户端便开始与服务器进行通信。
网页请求是一个客户端向服务器请求数据==>服务器返回相应数据的**单向**的请求过程。

- 浏览器根据URL生成HTTP请求，请求中包含请求文件的位置、请求文件的方式等信息；
- 服务器接到请求后，会根据HTTP请求中的信息来决定如何获取相应的HTML文件；
- 服务器将得到的HTML文件发送给浏览器；
- **在浏览器还没有完全接受完HTML文件时便开始渲染、显示页面**；
- 在执行HTML中代码时，根据需要，浏览器会继续请求图片、CSS、Javascript、视频、音频等文件，过程类似。

针对浏览器渲染、显示页面的过程，说明如下：

- 浏览器端是一个边解析边渲染的过程。
- HTML Parser将HTML内容解析为DOM Tree，CSS Parser将CSS内容解析为样式规则（Style Rules）；
- 根据样式规则和DOM Tree来渲染树(Render Tree)，在这个渲染树的过程中会发生**回流**（layout/reflow/relayout），回流就是浏览器计算各个盒模型的位置、大小等属性的过程；
- 等浏览器确定了盒模型的位置、尺寸等数据后开始绘制页面，这个过程称为**重绘**（Painting/repaint）。

### 4. 浏览器与服务器断开连接 {#four-way-hand-waving}

**断开连接——四次挥手**：

- 客户端向服务端先发送一个带有FIN标志的数据包（我想关闭）；
- 服务端接受FIN数据包之后，回传一个ACK的数据包给客户端以示传达确认关闭信息（知道了：只是表示确认我知道你想要关闭了，但是我可能还有事还在处理，不一定现在就关）
- 服务端向客户端发送一个FIN标志的数据包，请求关闭连接（我处理好了，可以关闭了）
- 客户端收到FIN的数据包之后，回传一个ACK的数据包给服务端，以表示确认关闭（好的，那我关了），服务器收到确认信号后断开连接。

说明：

- 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开；
- 第四次挥手后，主机发送确认信号后并没有立即断开连接，而是等待了2个报文传送周期，原因是：如果第四次挥手的确认信息丢失，服务器将会重新发送第三次挥手的断开连接的信号，而服务器发觉丢包与重新发送断开连接到达主机的时间正好为2个报文传输周期。
